unit TestuKBDynamic;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

  Performs test on TTestRecord with filled data by FillRecord (binary size
  of such record is about 150kB - but only in D2009+, see USE_DYNARRRECORD_INSIDE_RECORD)
  Each test is executed with all possible combinations of TKBDynamicOptions.

}

interface

uses
  TestFramework, Classes, SysUtils, uKBDynamic, Windows, TypInfo, Types;

{$IFDEF UNICODE}
  {$DEFINE USE_DYNARRRECORD_INSIDE_RECORD}
{$ENDIF}

const
{$IFDEF USE_DYNARRRECORD_INSIDE_RECORD}
  cTestRecordVersion = 2;
{$ELSE}
  cTestRecordVersion = 1;
{$ENDIF}

type

{ TTestRecord }

  TTestRecord = record
    I: Integer;
    D: Double;
    U: UnicodeString;
    W: WideString;
    A: AnsiString;
    Options: TKBDynamicOptions;

    IA: array[0..2] of Integer;

    AI: TIntegerDynArray;
    AD: TDoubleDynArray;
    AU: array of UnicodeString;
    AW: TWideStringDynArray;
    AA: array of AnsiString;

{$IFDEF USE_DYNARRRECORD_INSIDE_RECORD}
    // D2006 doesnt allow this, compiler bug?
    // In D2009/XE works fine
    R: array of TTestRecord;
{$ENDIF}
  end;

  TDynTestRecord = array of TTestRecord;

  // Test methods for class TKBDynamic

  TestTKBDynamic = class(TTestCase)
  protected
    FTestOptions: array of TKBDynamicOptions;

    procedure SetUp; override;

    procedure DoCompare(const ARec1, ARec2: TTestRecord);
    procedure DoTestSizeOfDynamic(AOptions: TKBDynamicOptions);
    procedure DoTestReadWriteDynamicToStream(AOptions: TKBDynamicOptions);

  public
    class procedure FillRecord(var ARec: TTestRecord; AOptions: TKBDynamicOptions;
      ASubRecs: Integer = 5);

  published
    procedure TestCompareDynamic;
    procedure TestSizeOfDynamic;
    procedure TestReadWriteDynamicToStream;
  end;

implementation

procedure TestTKBDynamic.SetUp;
var
  lIdx: Integer;
  lOptionsCount: Integer;
begin
  // Fill all possible options
  lOptionsCount := Integer(High(TKBDynamicOption)) + 1;
  SetLength(FTestOptions, lOptionsCount * lOptionsCount);
  for lIdx := 0 to High(FTestOptions) do
    PByte(@FTestOptions[lIdx])^ := lIdx;
end;

procedure TestTKBDynamic.DoCompare(const ARec1, ARec2: TTestRecord);
begin
  Check(TKBDynamic.Compare(ARec1, ARec1, TypeInfo(TTestRecord)));
  Check(TKBDynamic.Compare(ARec2, ARec2, TypeInfo(TTestRecord)));

  Check(TKBDynamic.Compare(ARec1, ARec2, TypeInfo(TTestRecord)));
  Check(TKBDynamic.Compare(ARec2, ARec1, TypeInfo(TTestRecord)));

  // Some simple checks
  Check(ARec1.Options = ARec2.Options);
  CheckEquals(ARec1.I, ARec2.I);
  CheckEquals(ARec1.D, ARec2.D);
  CheckEqualsString(ARec1.U, ARec2.U);
  CheckEqualsWideString(ARec1.W, ARec2.W); 
{$IFDEF USE_DYNARRRECORD_INSIDE_RECORD}
  CheckEquals(Length(ARec1.R), Length(ARec2.R));
  if Length(ARec1.R) > 0 then
    DoCompare(ARec1.R[High(ARec1.R)], ARec2.R[High(ARec2.R)]);
{$ENDIF}
end;

procedure TestTKBDynamic.DoTestSizeOfDynamic(AOptions: TKBDynamicOptions);
var
  lRec1, lRec2: TTestRecord;
  lStream1, lStream2: TMemoryStream;
begin
  FillRecord(lRec1, AOptions);
  FillRecord(lRec2, AOptions);

  CheckEquals(
    TKBDynamic.GetSize(lRec1, TypeInfo(TTestRecord), AOptions),
    TKBDynamic.GetSize(lRec2, TypeInfo(TTestRecord), AOptions));

  lStream1 := nil;
  lStream2 := nil;
  try
    lStream1 := TMemoryStream.Create;
    lStream2 := TMemoryStream.Create;

    // Write to TMemoryStream without prealocation, to test if GetSize
    // works correctly
    TKBDynamic.WriteTo(lStream1, lRec1, TypeInfo(TTestRecord), cTestRecordVersion, AOptions, False);
    TKBDynamic.WriteTo(lStream2, lRec2, TypeInfo(TTestRecord), cTestRecordVersion, AOptions, False);

    CheckEquals(lStream1.Size, TKBDynamic.GetSize(lRec1, TypeInfo(TTestRecord), AOptions));
    CheckEquals(lStream2.Size, TKBDynamic.GetSize(lRec2, TypeInfo(TTestRecord), AOptions));

    Check(CompareMem(lStream1.Memory, lStream2.Memory, lStream1.Size));

    CheckEquals(lStream1.Size, lStream2.Size);

  finally
    lStream1.Free;
    lStream2.Free;
  end;
end;

procedure TestTKBDynamic.DoTestReadWriteDynamicToStream(
  AOptions: TKBDynamicOptions);
var
  lRec1, lRec2: TTestRecord;
  lStream: TStream;
begin
  FillRecord(lRec1, AOptions);

  lStream := TMemoryStream.Create;
  try
    TKBDynamic.WriteTo(lStream, lRec1, TypeInfo(TTestRecord), cTestRecordVersion, AOptions);
    CheckEquals(lStream.Size, lStream.Position);

    lStream.Position := 0;
    Check(TKBDynamic.ReadFrom(lStream, lRec2, TypeInfo(TTestRecord), cTestRecordVersion));
    CheckEquals(lStream.Position, lStream.Size);

    DoCompare(lRec1, lRec2);
  finally
    lStream.Free;
  end;
end;

class procedure TestTKBDynamic.FillRecord(var ARec: TTestRecord;
  AOptions: TKBDynamicOptions; ASubRecs: Integer);
var
  lIdx: Integer;
begin
  Finalize(ARec);
  FillChar(ARec, SizeOf(ARec), 0);

  ARec.I := 10;
  ARec.D := 20.5;
  ARec.U := Self.ClassName;
  ARec.W := 'TEST';
  ARec.A := 'AnsiTest';
  ARec.Options := AOptions;

  ARec.IA[0] := ASubRecs;
  ARec.IA[1] := ASubRecs * 2;
  ARec.IA[2] := ASubRecs * 4;

  SetLength(ARec.AI, 10);
  for lIdx := 0 to High(ARec.AI) do
    ARec.AI[lIdx] := lIdx * 2;

  SetLength(ARec.AD, 10);
  for lIdx := 0 to High(ARec.AD) do
    ARec.AD[lIdx] := lIdx * 3.14;

  SetLength(ARec.AU, 4);
  for lIdx := 0 to High(ARec.AU) do
    ARec.AU[lIdx] := ARec.U + IntToStr(lIdx);

  SetLength(ARec.AW, 2);
  for lIdx := 0 to High(ARec.AW) do
    ARec.AW[lIdx] := ARec.W + IntToStr(lIdx);

  SetLength(ARec.AA, 3);
  for lIdx := 0 to High(ARec.AA) do
    ARec.AA[lIdx] := ARec.A + AnsiString(IntToStr(lIdx));

{$IFDEF USE_DYNARRRECORD_INSIDE_RECORD}
  SetLength(ARec.R, ASubRecs);
  for lIdx := 0 to High(ARec.R) do
    FillRecord(ARec.R[lIdx], AOptions, ASubRecs - 1);
{$ENDIF}
end;

procedure TestTKBDynamic.TestCompareDynamic;
var
  lRec1, lRec2: TTestRecord;
begin
  FillRecord(lRec1, TKBDynamicDefaultOptions);
  FillRecord(lRec2, TKBDynamicDefaultOptions);

  DoCompare(lRec1, lRec2);
end;

procedure TestTKBDynamic.TestSizeOfDynamic;
var
  lIdx: Integer;
begin
  for lIdx := 0 to High(FTestOptions) do
    DoTestSizeOfDynamic(FTestOptions[lIdx]);
end;

procedure TestTKBDynamic.TestReadWriteDynamicToStream;
var
  lIdx: Integer;
begin
  for lIdx := 0 to High(FTestOptions) do
    DoTestReadWriteDynamicToStream(FTestOptions[lIdx]);
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTKBDynamic.Suite);
end.

